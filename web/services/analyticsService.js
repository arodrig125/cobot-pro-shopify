const prisma = require('../prismaClient');

/**
 * Analytics Service for Cobot Pro
 * Handles tracking, reporting, and analysis of upsell performance
 */

/**
 * Track an upsell impression
 * @param {Object} data - Impression data
 * @param {string} data.upsellId - The upsell rule ID
 * @param {string} data.shopDomain - The shop's domain
 * @param {string} data.customerId - The customer ID (optional)
 * @param {string} data.sessionId - The session ID
 * @returns {Promise<void>}
 */
async function trackImpression(data) {
  try {
    const { upsellId, shopDomain, customerId, sessionId } = data;
    
    // Get the store ID from the domain
    let storeId = null;
    if (shopDomain) {
      const store = await prisma.store.findUnique({
        where: { domain: shopDomain },
        select: { id: true }
      });
      
      if (store) {
        storeId = store.id;
      }
    }
    
    // Update the upsell rule's impression count
    await prisma.upsell.update({
      where: { id: parseInt(upsellId) },
      data: { impressions: { increment: 1 } }
    });
    
    // Update or create the daily analytics record
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    await prisma.analytics.upsert({
      where: {
        storeId_date: {
          storeId,
          date: today
        }
      },
      update: {
        impressions: { increment: 1 }
      },
      create: {
        storeId,
        date: today,
        impressions: 1,
        conversions: 0,
        revenue: 0
      }
    });
    
    console.log(`ðŸ“Š Tracked impression for upsell ${upsellId}`);
  } catch (error) {
    console.error('Error tracking impression:', error);
    // Don't throw - analytics errors shouldn't break the main flow
  }
}

/**
 * Track an upsell conversion
 * @param {Object} data - Conversion data
 * @param {string} data.upsellId - The upsell rule ID
 * @param {string} data.shopDomain - The shop's domain
 * @param {string} data.customerId - The customer ID (optional)
 * @param {string} data.sessionId - The session ID
 * @param {number} data.revenue - The revenue generated by this upsell
 * @returns {Promise<void>}
 */
async function trackConversion(data) {
  try {
    const { upsellId, shopDomain, customerId, sessionId, revenue = 0 } = data;
    
    // Get the store ID from the domain
    let storeId = null;
    if (shopDomain) {
      const store = await prisma.store.findUnique({
        where: { domain: shopDomain },
        select: { id: true }
      });
      
      if (store) {
        storeId = store.id;
      }
    }
    
    // Update the upsell rule's conversion count and revenue
    const upsell = await prisma.upsell.update({
      where: { id: parseInt(upsellId) },
      data: { 
        conversions: { increment: 1 },
        revenue: { increment: parseFloat(revenue) }
      }
    });
    
    // Calculate and update the conversion rate
    if (upsell.impressions > 0) {
      const conversionRate = (upsell.conversions / upsell.impressions) * 100;
      await prisma.upsell.update({
        where: { id: parseInt(upsellId) },
        data: { conversionRate }
      });
    }
    
    // Update or create the daily analytics record
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    await prisma.analytics.upsert({
      where: {
        storeId_date: {
          storeId,
          date: today
        }
      },
      update: {
        conversions: { increment: 1 },
        revenue: { increment: parseFloat(revenue) }
      },
      create: {
        storeId,
        date: today,
        impressions: 0,
        conversions: 1,
        revenue: parseFloat(revenue)
      }
    });
    
    console.log(`ðŸ“Š Tracked conversion for upsell ${upsellId} with revenue ${revenue}`);
  } catch (error) {
    console.error('Error tracking conversion:', error);
    // Don't throw - analytics errors shouldn't break the main flow
  }
}

/**
 * Get performance metrics for upsell rules
 * @param {Object} filters - Filters for the metrics
 * @param {string} filters.storeId - The store ID
 * @param {string} filters.startDate - Start date for the metrics
 * @param {string} filters.endDate - End date for the metrics
 * @returns {Promise<Object>} - Performance metrics
 */
async function getPerformanceMetrics(filters = {}) {
  try {
    const { storeId, startDate, endDate } = filters;
    
    // Build the where clause
    const where = {};
    
    if (storeId) {
      where.storeId = parseInt(storeId);
    }
    
    if (startDate && endDate) {
      where.date = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      };
    } else if (startDate) {
      where.date = {
        gte: new Date(startDate)
      };
    } else if (endDate) {
      where.date = {
        lte: new Date(endDate)
      };
    }
    
    // Get the analytics data
    const analyticsData = await prisma.analytics.findMany({
      where,
      orderBy: {
        date: 'asc'
      }
    });
    
    // Calculate the metrics
    const totalImpressions = analyticsData.reduce((sum, record) => sum + record.impressions, 0);
    const totalConversions = analyticsData.reduce((sum, record) => sum + record.conversions, 0);
    const totalRevenue = analyticsData.reduce((sum, record) => sum + record.revenue, 0);
    const conversionRate = totalImpressions > 0 ? (totalConversions / totalImpressions) * 100 : 0;
    
    // Get the top performing upsell rules
    const topRules = await prisma.upsell.findMany({
      where: {
        storeId: storeId ? parseInt(storeId) : undefined
      },
      orderBy: {
        revenue: 'desc'
      },
      take: 5
    });
    
    // Format the daily data for charts
    const dailyData = analyticsData.map(record => ({
      date: record.date.toISOString().split('T')[0],
      impressions: record.impressions,
      conversions: record.conversions,
      revenue: record.revenue,
      conversionRate: record.impressions > 0 ? (record.conversions / record.impressions) * 100 : 0
    }));
    
    return {
      summary: {
        totalImpressions,
        totalConversions,
        totalRevenue,
        conversionRate,
        averageOrderValue: totalConversions > 0 ? totalRevenue / totalConversions : 0
      },
      topRules: topRules.map(rule => ({
        id: rule.id,
        triggerProductId: rule.triggerProductId,
        upsellProductId: rule.upsellProductId,
        impressions: rule.impressions,
        conversions: rule.conversions,
        revenue: rule.revenue,
        conversionRate: rule.conversionRate
      })),
      dailyData
    };
  } catch (error) {
    console.error('Error getting performance metrics:', error);
    throw error;
  }
}

module.exports = {
  trackImpression,
  trackConversion,
  getPerformanceMetrics
};
